# コーディングテスト対策問題（サーバーサイド）- ステップ1

このプロジェクトは、コーディングテストのサーバーサイド実装問題について、PythonのFlask、およびSQLAlchemyを用いて実装を行いました。このREADMEでは、初学者がつまずきやすいポイントや、なぜそのように実装しているのかといった考え方を重点的に解説します。
他の言語やフレームワーク、ORMを用いた方は、コミュニティで共有して議論しあうこともできます。

## 課題の概要

課題は、メモ管理システムのAPIを実装することです。このAPIは以下の機能を持ちます：

1. **メモの作成**
2. **メモの取得**
3. **メモの更新**
4. **メモの削除**

このAPIを、FlaskというPythonのWebフレームワークを使って実装します。また、アプリケーションをDocker上で動かすことで、環境の一貫性を保ちながら開発します。

## Flaskの概要とクラスの使用

### Flaskとは？

FlaskはPythonの軽量なWebフレームワークで、APIやWebアプリケーションを素早く作成するために使われます。Flaskが「軽量」と呼ばれる理由は、基本的な機能に絞られており、必要に応じて追加の機能を簡単に拡張できるからです。

### クラスとは？

クラスは、Pythonをはじめとするオブジェクト指向プログラミングの基本概念です。クラスは、データ（属性）と、そのデータを操作する関数（メソッド）をまとめて定義するための設計図のようなものです。

#### 例: `Memo` クラス

```
class Memo(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    title = db.Column(db.String(80), nullable=False)
    content = db.Column(db.Text, nullable=False)
    created_at = db.Column(db.DateTime, nullable=False, default=datetime.utcnow)
    updated_at = db.Column(db.DateTime, nullable=False, default=datetime.utcnow, onupdate=datetime.utcnow)
```

このクラスは、メモのデータを表現しています。`title` や `content` など、メモに関する情報を属性として持っています。また、このクラスを使うことで、データベース内でメモを簡単に操作できます。

### クラスを使うメリット

- **再利用性**: 一度クラスを定義すれば、何度でも使い回すことができます。同じメモデータを扱うときに、再び構造を考える必要はありません。
- **データと操作をまとめる**: クラスはデータとそのデータを操作するメソッドを一緒に定義できるため、コードの可読性やメンテナンス性が向上します。

## なぜDockerを使うのか？

### Dockerとは？

Dockerは、アプリケーションをコンテナという仮想環境内で実行するためのツールです。これにより、異なる環境間でアプリケーションが動作することを保証できます。たとえば、開発環境では動くが本番環境では動かないといった問題を回避できます。

### Dockerを使うメリット

- **環境の一貫性**: Dockerコンテナはどこで実行しても同じように動作します。これにより、開発者全員が同じ環境で開発できます。
- **依存関係の管理**: アプリケーションが依存するライブラリやツールをDockerイメージに含めるため、ローカルマシンの環境に依存しません。
- **簡単なセットアップ**: Dockerを使えば、複雑なセットアップを一度イメージにまとめておけば、あとはそれを起動するだけで環境が整います。

## 実装の解説

### メモ作成API (`POST /api/memos`)

ユーザーがメモを作成するためのエンドポイントです。このエンドポイントに対して、メモのタイトルと内容を含むJSONデータを送信すると、新しいメモがデータベースに保存されます。

```
@app.route('/api/memos', methods=['POST'])
def create_memo():
    data = request.get_json()
    new_memo = Memo(
        title=data['title'],
        content=data['content'],
    )
    db.session.add(new_memo)
    db.session.commit()
    return jsonify({
        "id": new_memo.id,
        "title": new_memo.title,
        "content": new_memo.content,
        "createdAt": new_memo.created_at,
        "updatedAt": new_memo.updated_at
    }), 201
```

#### なぜ `jsonify` を使うのか？

`jsonify` は、PythonのデータをJSON形式に変換し、HTTPレスポンスとして返すための便利な関数です。APIでは通常、クライアントとサーバー間でJSON形式でデータをやり取りするため、`jsonify` を使うことで簡単にレスポンスを作成できます。

### エラーハンドリング

APIを実装するとき、クライアントが存在しないメモをリクエストするなど、何らかのエラーが発生することがあります。この場合、適切なHTTPステータスコード（例: 404 Not Found）を返すことが重要です。

```
@app.route('/api/memos/<int:id>', methods=['GET'])
def get_memo(id):
    memo = Memo.query.get_or_404(id)
    return jsonify({
        "id": memo.id,
        "title": memo.title,
        "content": memo.content,
        "createdAt": memo.created_at,
        "updatedAt": memo.updated_at
    })
```

#### `get_or_404` とは？

`get_or_404` は、指定されたIDのデータをデータベースから取得し、見つからなければ自動的に404エラーを返します。これにより、エラーハンドリングが簡潔になり、コードが整理されます。

## Dockerの構成

### `Dockerfile` のポイント

`Dockerfile` は、アプリケーションをどのようにコンテナ化するかを定義します。

- **ベースイメージの選択**: `python:3.9-slim` を使用して、Python環境を最小限のサイズで提供します。
- **依存関係のインストール**: `requirements.txt` を使って必要なライブラリをインストールします。
- **ポートの公開**: Flaskアプリケーションが使用するポート5000を外部に公開します。

### `docker-compose.yml` のポイント

`docker-compose.yml` は、複数のコンテナをまとめて管理するためのツールです。このファイルを使うことで、開発環境を一括して起動・停止できるようになります。

- **サービスの定義**: `web` という名前でFlaskアプリケーションを定義しています。
- **ポートのマッピング**: ローカルの5000番ポートをコンテナの5000番ポートに接続することで、ローカル環境からコンテナ内のアプリケーションにアクセスできるようにしています。

## よくあるつまずきポイント

### 1. **依存関係の問題**

依存関係が正しくインストールされないことがあります。例えば、`pip install` でエラーが出た場合、`requirements.txt` が正しく指定されているか確認しましょう。

### 2. **ポートの競合**

他のアプリケーションがポート5000を使用している場合、Flaskアプリケーションが正しく起動しないことがあります。別のポート（例: 5001）を指定して起動することで解決できます。

### 3. **データベースが作成されない**

Flaskアプリケーションが初めて起動する際に、データベースのテーブルが自動的に作成されない場合があります。この場合、`app.py` の `db.create_all()` が正しく呼ばれているか、データベースの設定が正しいかを確認してください。

## まとめ

このプロジェクトを通じて、Flaskを使ったAPIの構築方法と、Dockerを使った環境構築の基本を学びました。クラスや関数の使い方、エラーハンドリングの重要性、そしてDockerを使うことで得られる環境の一貫性など、多くの重要な概念を理解することができたでしょう。実際に手を動かしてコードを書きながら学ぶことで、これらの概念がより深く理解できるはずです。
